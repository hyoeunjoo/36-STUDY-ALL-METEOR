public class Solution {
    public String solution(int n, int m, int x, int y, int r, int c, int k) {
        // 1. 최단 거리 계산
        int minDistance = Math.abs(x - r) + Math.abs(y - c);
        
        // 2. 불가능한 경우 판단
        // - k가 최단 거리보다 작은 경우
        // - (k - 최단거리)가 홀수인 경우
        if (k < minDistance || (k - minDistance) % 2 != 0) {
            return "impossible";
        }
        
        // 3. 그리디 알고리즘으로 사전순 최소 경로 생성
        StringBuilder answer = new StringBuilder();
        int currentX = x;
        int currentY = y;
        int remainingMoves = k;
        
        // 방향 (항상 나오는거)
        int[] dx = {1, 0, 0, -1};
        int[] dy = {0, -1, 1, 0};
        char[] directions = {'d', 'l', 'r', 'u'};
        
        // 매 단계마다 사전순으로 가장 빠른 방향 선택
        while (remainingMoves > 0) {
            for (int i = 0; i < 4; i++) {
                int nextX = currentX + dx[i];
                int nextY = currentY + dy[i];
                
                // 격자 범위 체크
                if (nextX < 1 || nextX > n || nextY < 1 || nextY > m) {
                    continue;
                }
                
                // 핵심: 다음 위치에서 남은 이동으로 목표 도달 가능한지 확인
                int distanceFromNext = Math.abs(nextX - r) + Math.abs(nextY - c);
                
                // 남은 이동 횟수 - 1번으로 목표까지 도달 가능하면 이동
                if (distanceFromNext <= remainingMoves - 1) {
                    answer.append(directions[i]);
                    currentX = nextX;
                    currentY = nextY;
                    remainingMoves--;
                    break;
                }
            }
        }
        
        return answer.toString();
    }
}